一，简介
	JavaEE作为一种企业级应用开发平台，其优异的表现是我们有目共睹的。但是，要想合理并充分的发挥其平台提供的各项服务，就需要一个优秀的框架，Spring便呼之即出。它是一
个轻量级的Java开发框架。在Spring之前，开发人员使用的最广泛的JavaEE开发框架当属EJB了，它也是使用JavaEE平台各项服务的一种方式，但是更适用于分布式环境（场景），
EJB由于最佳场景的限制，其缺点也是显露无疑：需要拥有EJB Container的应用服务器；增加开发，测试，部署的复杂度；最佳场景为分布式（中小型应用不适合）。

二，基于Spring的功能树
最底层：Core核心模块——IoC容器、Framework工具类（IO工具类等）
基于核心core的上层模块：
	（1）AOP模块：提供了一个AOP框架，可以以AOP的形式增强各POJO，采用proxy模式构建，与底层IoC容器结合，可以显示出其强大的威力。
		（1.1）Spring框架在core核心模块和AOP模块的基础之上，为我们提供了完备的数据访问和事务管理的抽象和集成服务。（DAO，Spring JDBC，事务管理）
		（1.2）Spring框架为各种当前业界流行的ORM产品：Hibernate、iBATIS、JTA等提供了形式统一的集成支持。
	（2）集成封装简化各种Java EE服务的使用：JNDI、JMS、JavaMail、Remoting等。
	（3）Web模块：Spring框架提供了一套自己的Web MVC框架——Spring MVC以及基于此的Spring Portlet MVC；与此同时，Spring框架同样对诸如Struts
	                                的其他的Web框架提供了集成支持；此外，Spring还集成了各种视图类型。
	
三，Spring IoC容器
	IoC，Inversion of Control，即控制反转，它还有一个别名叫依赖注入（也有说依赖注入是控制反转的一种方式）。以前我们要在一个类中使用另一个类提供的服务，通常
会在构造函数中new一个依赖对象，这是一种主动直接获取的方式。IoC则避免了这种主动获取的方式，它的反转就是从原来的事必躬亲变成现在的享受服务，所有的被注入对象和依赖对象都
由IoC Service Provider统一管理，被注入对象需要什么服务直接通知一下，后者就会将被依赖对象注入到其中，依赖对象的取得方式发生了反转，控制权也从被注入对象转到了IoC
Service Provider。
	那么被注入对象是通过哪些方式来通知IoC Service Provider为其提供服务的呢？
	通常有三种方式：构造函数注入、setter方法注入以及接口注入（侵入式较强，逐渐被淘汰）。
（1）IoC Service Provider（ISP）
	IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以
是比较通用的IoC框架或者IoC容器实现。
	IPerson person = new Man();
	IWork work = new MakeMoney();
	PersonProvider provider = new PersonProvider(person, work);
	provider.getWorkPerson();
	上面的代码就是一个最简易的IoC Service Provider。同样，Spring的IoC容器就是一个提供依赖注入服务的IoC Service Provider。ISP的职责主要有两个：
业务对象的构建管理和业务对象间的依赖绑定。
	业务对象的构建管理（注册）在IoC容器启动的时候完成。而决定业务对象间的依赖绑定关系通常有三种方式：
	直接编码方式：
	IoContainer container = ....; // 获取容器
	container.register(PersonProvider.class, new PersonProvider()); // 注册业务类
	container.register(IPerson.class, new Man()); // 注册业务对象，为相应的类指定具体的实例
	... 
	PersonProvider provider = (PersonProvider)container.get(PersonProvider.class); // 直接从容器中获取所需类对象即可
	provider.getWorkPerson();
	
	配置文件方式（更为普遍）：
	<bean id="provider" class="..PersonProvider">
		<property name="person">
			<ref bean="man"/>
		</property>
	</bean>
	<bean id="man" class="..impl.Man"/>
	<bean id="work" class="..impl.MakeMoney"/>
	
	元数据方式（略）
	
四，Spring容器之BeanFactory
	Spring提供了两种容器类型：BeanFactory和ApplicationContext。
	BeanFactory是一个基础类型的IoC容器，默认采用延迟初始化策略，适用于资源有限的场景。BeanFactory作为Spring提供的基本容器类型，可以完成作为
ISP的所有职责，包括业务对象的注册和依赖关系的绑定。显然，BeanFactory会提供一个获取对象的方法接口（getBean(..)方法等）。
	注意，补充一下，是否引入容器，对业务接口与实现类的设计是没有影响的，它影响的是对象的获取方式和对象间的依赖关系。
	使用Xml可以进行bean的管理，还可以解决bean的依赖关系，Spring的<bean>标签提供了两种解决bean之间依赖关系的方式：
	（1）构造方法注入，使用的标签是<constructor-arg>，需要被注入bean对象提供对应的构造方法
	<bean id="provider" class="..PersonProvider"/>
		<constructor-arg ref="man">
	</bean>
	（2）setter方法注入，使用的标签是<property>，需要被注入的bean对象提供对应的setPerson()方法
	<bean id="provider" class="..PersonProvider">
		<property name="person" value="man"/>
	</bean>
	实际选择时最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。

五，Spring容器之ApplicationContext
	ApplicationContext在BeanFactory的基础之上构建，提供更多功能（如事件发布、国际化信息支持、统一资源加载策略等），属于高级容器。该接口的直接子类
是AbstractApplicationContext。（区别于Struts1/Struts2的ServletContext/ActionContext：Action之间相互通信以及资源路径等）
	Spring为基础容器BeanFactory提供了XMLBeanFactory实现，同样，它也为ApplicationContext类型的容器提供了以下常用的实现：
	（1）FileSystemXMLApplicationContext：默认情况下，从文件系统加载bean定义以及相关资源的ApplicationContext实现；
	（2）ClassPathXMLApplicationContext：默认情况下，从classpath加载定义以及相关资源的ApplicationContext实现；
	（3）XMLWebApplicationContext：用于Web应用的ApplicationContext实现。
	
	统一资源加载策略：Spring框架内部使用org.springframework.core.io.Resource接口作为所有资源的抽象和访问接口，Resource接口可以根据资源
		的不同类型，或则资源所处的不同场合，给出相应的具体实现，Spring框架在这个理念的基础上，提供了一些实现类，比如ClassPathResource。
		对于资源的加载，ApplicationContext间接继承了ResourceLoader接口，因此任何ApplicationContext实现都是一个资源加载器。
	

